---
ebook:
  theme: one-dark.css
  title: 객체지향
  authors: Escatrgot
  disable-font-rescaling: true
  margin: [0.1, 0.1, 0.1, 0.1]
---
<style>
    h3.quest { font-weight: bold; border: 3px solid; color: #A0F !important;}
    .quest { font-weight: bold; color: #A0F !important;}

    h2 { border-top: 12px solid #45C1A4; border-left: 5px solid #45C1A4; border-right: 5px solid #45C1A4; background-color: #45C1A4; color: #FFF !important; font-weight: bold;}

    h3 { border-top: 3px solid #FFF; border: 2px solid #FFF; background-color: #FFF; color: #45C1A4 !important;}

    h4 { font-weight: bold; color: #FFF !important; }
</style>

## ⏱️ 1. Async 개요

<img src="./img/2023-02-11-17-54-50.png">

#### 병렬적으로 함수를 다루는법을 사용해보자. 설령 병렬적인 처리를 직렬적으로 다루고 싶을떄도 그 방법을 알아보자.

---

### 📄 1. 동기 비동기
#### 동기적 (Imperative 직렬적) 
* 끝날때까지 대기
  * 요청을 보낸후 해당 음답을 받아야 다음 동작을 실행
  * 실행이 끝나고 다음 실행
  * 함수, 단일객체

#### 비동기 (Asynchronouse 병렬적)
* 끝날때까지 대기 안함
  * 요청을 보낸 후 응답에 관계 없이 다음 동작을 실행
  * 실행중에도 다음 실행


### 📄 2. 동기 비동기의 존재 의의 

#### 장점

오래 실행될 가능성이 있는 함수는 비동기 처리, 게임이 Blocking 되는일 없게 병렬처리를 하는게 좋다.


### 📄 3. 스레드 풀

#### 스레드 풀은 뭔데?

![](./img/2023-02-19-00-43-07.png)
```
1. **스레드**
    * 하나의 프로세스에 단일 스레드, 다중 스레드가 존재한다.
    * 운영체제 관점으로 다중수행(병렬처리) 의 최소 단위를 스레드라고 말한다.
    * 코드를 수행하는 주체
    * 실행 자원을 공유한다.

2. **Pool**
    생성과 삭제는 비용이 많이 든다. 생성과 삭제를 한꺼번에 모아서 할 수는 없을까?

    이제 그 모으는 "틀"을 Pool 이라고 한다.

    * 대량구매. 한꺼번에 모아서 구매(처리)를 같이한다.
    * 생성도 대량으로 처리도 대량을 한꺼번에 처리하는 방식이다.
    * 대량으로 영역을 확보한 후 그 확보한 영역만을 사용하여 데이터를 할당하는 방법

    * 자 그럼 모은다는것은 어떻게 모아지는것이지? 
    선입선출(FIFO) 바로 그 작업(함수동작)을 "큐" 로 모으는것이다. *줄서세요 줄서*
```

#### 그래서 스레드 풀은.

![](./img/2023-02-19-00-54-58.png)

1. **스레드는 얼마나 필요할지몰라서 다 준비해둔다. 스레드 풀이 스레드를 미리 적당히 생성해 놓는다**
2. **작업(Task)를 큐에 넣어 하나씩 스레드가 맡아 처리한다**
3. **기다리는것을 통해 작업을 처리한다.**
4. **작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다.**

5. 작업 처리 요청이 폭증해도 작업을 처리하는 스레드를 만들고 삭제하는 작업을 안하기에 애플리케이션 스레드 풀은 비교적 애플리케이션 저하가 없이 작업을 처리한다.

#### **흐름**
  1. 작업 단위를 담는 스레드라는 클래스가 있다.
  2. 그 스레드는 얼마나 필요할지몰라서 다 준비해둔다.
  3. 그 클래스를 큐에다 넣는다.
  4. 큐에 들어오느 클래스는 선입선출로 스레드 각각에 넣어 작동한다.
  5. 처리가 끝나면 스레드는 결과를 내보내고 다시 빈 스레드가 있다.

#### 결정적으로 비동기 동작의 기본은 모두 이 스레드 풀을 이용한 다는 것이다.

> [출처] 비동기 프로그래밍 - 개요|작성자 에로로

### 📄 4. 스레드 관점 동기 VS 비동기
1. 동기 : 스레드가 1개라는것
   * 그 스레드는 Main()이 되는 메인 스레드
   * 메인 스레드가 하드웨어 작업을 요청한 후, 동기 동작처럼 하드웨어 작업 완료를 기다림
2. 비동기 : 스레드가 2개 이상이라는것
   * 메인 스레드가 별도의 스레드를 생성하여 이 스레드가 하드웨어 작업 완료를 기다리게 하는 것이다.
   그 사이 메인 스레드는 그 다음 코드를 계속해서 실행하게 되고
   하드웨어 작업이 완료될 때 대기하게 만들었던 스레드로부터 결과를 전달받는 형식이 되는 것이다.

### 📄 5. Thread Safe
#### 쓰레드 세이프 (Thread Safe)
* 다수의 스레드들이 특정 자원을 공유할 때 
자원의 상태 변화, 접근 순서에 따라 여러 가지 문제가 발생하게 되는데
이러한 문제를 해결하기위해 Synchronize(동기) 기법을 사용해야한다. 
* 웬만해서 비동기 프로그램은 전혀 다른 일을 처리할 때 사용하도록.
* C# 필드 변수의 비동기 접근을 할시
Lock 키워드를 사용해야한다.

### 📄 7. 유니티의 스레드?
#### 유니티는 단일 쓰레드만 지원한다. (메인 스레드만 유니티 메인 로직에 접근가능하다)

C# JobSystem을 사용한다면 유니티에서도 멀티스레드를 안전하게 사용할 수 있다.

### 📄 8. C#의 비동기 모델

**① APM**
  * IAsyncResult를 이용한다
  * 클래스 A는
    * 외부에서 호출할 비동기 수행할 매서드를 가지고 있고. 델리게이트 형식으로 엮어진다.
    * 비동기 호출 BeginInvoke()
    * 비동기 호출 종료 
    * 콜백에서 비동기 결과 반환
  
**② EAP**
  * 비동기 작업 시작하면 작업 상황을 이벤트로 외부에 전달
  * 작업이 종료되면 작업 종료 이벤트를 발생시킴
  * 비동기로 수행하고자 하는 작업은 델리게이트 호출이 핵심이다
  * Case  
    1. 한번에 한 작업만 처리 : 동기적으로 할수도 (단일 호출 방식)
    2. 연속적으로 계속 호출 : 요청이 들어오는대로 비동기 처리 (다중 호출방식)
  * SynchronizationContext : 
    1. 클래스 생성.
    2. 이벤트 추가.
      * 2-1. 종료 이벤트 추가.
      * 2-2. 과정 이벤트 추가.
      (EventArgs 도 함께 추가.)
    3. AsyncOperation 추가
    4. SendOrPostCallback 추가
      * 4-1 종료 이벤트를 발생시킬 델리게이트 추가.
      * 4-2 과정 이벤트를 발생시킬 델리게이트 추가.
    5. 비동기 시작 델리게이트 추가.
    6. 비동기 시작 메서드 추가.
    7. 동기(작업) 메서드 추가.

**③ TAP 작업 기반 비동기 패턴**
  * async await
  * IProgress
  * (동기 메서드 하나 만들고), (동기 -> 비동기로 동작하게 하기)
  * 비동기 작업의 결과(혹은 전달하는 방법)에 초점을 맞춰져 있었다면 
  **"작업 기반 비동기 패턴은 비동기 작업 자체에 그 초점이 맞춰져 있다."**
  * 비동기 작업 결과에 대한 통보
    1. 작업이 끝날때 까지 기다렸다가 반환되는 결과를 받아 처리
    2. 비동기 작업이 끝났다는 사실을 메인 스레드에 통보하는것
       1. 콜백 : APM
       2. 이벤트 : EAP
  * “앞서 말했던 모든 비동기 기능을 사용할 수 있는 클래스가 제공된다.
    (달리 말하면 비동기 작업에 필요한 기능을 담은 하나의 클래스를 제공해 준다는 의미도 된다)

### 📄 참조

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-multi-process-multi-thread

https://adrianmejia.com/asynchronous-vs-synchronous-handling-concurrency-in-javascript/

https://velog.io/@jinuku/C-async-await%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%A5%BC-%EB%8F%99%EA%B8%B0%EC%B2%98%EB%9F%BC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1

https://mentum.tistory.com/689

http://blog.naver.com/vactorman/80167386667
