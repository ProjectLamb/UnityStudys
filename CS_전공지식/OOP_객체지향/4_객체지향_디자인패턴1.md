---
ebook:
  theme: github-light.css
  title: 객체지향
  authors: Escatrgot
  disable-font-rescaling: true
  margin: [0.1, 0.1, 0.1, 0.1]
---
<style>
    h3.quest { font-weight: bold; border: 3px solid; color: #A0F !important;}
    .quest { font-weight: bold; color: #A5F !important;}
    h2 { border-top: 12px solid #D40; border-left: 5px solid #D40; border-right: 5px solid #D40; background-color: #D40; color: #FFF !important; font-weight: bold;}
    h3 { border-top: 12px solid #F90; border: 5px solid #F90; background-color: #F90; color: #FFF !important;}
</style>

## 📕 4. 객체지향 디자인 패턴

#### 유니티에서 사용하면 좋을 디자인 패턴만 명시한다.

---

### 📄 0. SOLID Principle 

`1. SRP, 2. OCP, 3. LSP, 4. ISP, 5. DIP`

> 여기서 변경한다, 바뀐다 하는것

#### 1). SRP (Single Responsibility Principle)
<p align="center">
    <img src=https://imgur.com/tXg47c7.png width=400px>
</p>

**ⓐ 단일 책임 원칙 : 클만변**
1. 클래스 만들때 : 걔는 단 하나의 책임을 가져야한다
2. 클래스 변경할때 : 걔는 단 한가지 이유가 있어야한다

* 높은 응집력과 낮은 결합

**ⓒ 예시**
<details>
   <summary style="cursor:pointer; text:bold"><b>📂SRP BAD 🤪📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  class BlogPost
  {
      private Author author;
      private string title;
      private string content;
      private DateTime date;
      // ..
      public Dictionary getData()
      {
          Dictionary<string, string> ret = new Dictionary<string, string>();
          ret.Add("author", this.author.fullName());
          ret.Add("title", this.title);
          ret.Add("content", this.content);
          ret.Add("timestamp", this.date.getTimestamp());
          return ret;
      }

      public String printJson() { return json_encode(getData()); }

      public String printString()
      {
          return $"{this.title} {this.date.setFormat("Y-m-d H:i:s")} {this.author.fullName()} {this.content}";
      }
  }

  //여기서 주요 문제는 
  //필요한 경우 다양한 형식, json, html 등으로 인쇄를 담당한다는 것입니다. 
  //그럼 이것이 어떻게 개선될 수 있는지 봅시다.
  ```

</details>
<details>
   <summary style="cursor:pointer; text:bold"><b>📂SRP GOOD 😎📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  class BlogPost
  {
      private Author author;
      private string title;
      private string content;
      private DateTime date;
      // ..
      public Dictionary getData()
      {
          Dictionary<string, string> ret = new Dictionary<string, string>();
          ret.Add("author", this.author.fullName());
          ret.Add("title", this.title);
          ret.Add("content", this.content);
          ret.Add("timestamp", this.date.getTimestamp());
          return ret;
      }
  }

  //BlogPost 클래스에서 인쇄 방법을 제거
  interface IPrintableBlogPost
  {
      public string print(BlogPost _blogPost);
  }

  class JsonBlogPostPrinter : IPrintableBlogPost
  {
      public string print(BlogPost _blogPost)
      {
          return json_encode(_blogPost.getData());
      }
  }

  class HtmlBlogPostPrinter : IPrintableBlogPost
  {
      public string print(BlogPost _blogPost)
      {
          return $"{_blogPost.getData().title}" +
              $"{_blogPost.getData().date.setFormat("Y-m-d H:i:s")}" +
              $"{_blogPost.getData().author.fullName()}" +
              $"{_blogPost.getData().content}";
      }
  }
  ```
</details>
<details>
   <summary style="cursor:pointer; text:bold"><b>📂Python : SRP 비준수와 준수📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```python
  # 다음은 두개의 기능이 섞여있어 옳지 않다
  def addPrint(a, b):
      res = a + b
      print(res)
  # 다음과 같이 단 하나의 책임으로 분리하자


  def add(a, b):
      return a + b


  def printf(str):
      print(str)
  ```

</details>

#### 2). OCP (Open-Closed Principle) 

<p align="center">
    <img src=https://imgur.com/q0B1w4G.png width=400px>
</p>

**ⓐ 확장-폐쇠 원칙**

* 확변
    1. 확장시
       * 열려있어야함
    2. 변경시
       * 닫혀있어야함

**ⓑ 정확한 설명**

* 
    ```text
    1. 새로운 기능을 추가싶을때 있다.
    2. 그런데 추가 시킬때마다 만들었던 코드를 수정해야된다면
    3. 너무 불편하지 않겠나? (애초에 수정이라는 과정에서 버그가 발생하기 마련이다)
    4. 그러지말고 그냥 한줄만 추가해도 기능 확장이 쉬운 구조로 만들자는것
    ```

**ⓒ 예시**
<details>
   <summary style="cursor:pointer; text:bold"><b>📂OCP BAD 🤪📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  class Dog {
      public string bark() { return "woof woof";}
  }

  class Duck{    
      public string bark() { return "quack quack";}    
  }

  class Fox {
      public string whatDoesTheFoxSay() { return "ring-ding-ding-ding-dingeringeding!, Wa-pa-pa-pa-pa-pa-pow!";}
  }

  class Communication {
      public string communicate(?????? _animal)
      {
          switch (true) {
              case animal.IsInstanceOfType(Dog):
                  return animal.bark();
              case animal.IsInstanceOfType(Duck):
                  return animal.quack();
              case animal.IsInstanceOfType(Fox):
                  return animal.whatDoesTheFoxSay();
              default:
                  throw new InvalidArgumentException("Unknown animal");
          }
      }
  }

  //기존 코드를 변경하지 않고 새 동물 클래스를 추가할 수 있습니까? 
  //새 동물 클래스를 추가하려면 communi () 함수에서 스위치를 수정해야 합니다. 

  //게다가 벌써부터 communicate에 오류가 났다.
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂OCP 준수 😎📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  interface IComunicatable
  {
      public string speak();
  }

  class Dog : IComunicatable
  {
      public string speak() { return "'woof woof'"; }
  }

  class Duck : IComunicatable {   
      public string speak() { return "'quack quack'"; }
  }

  class Fox : IComunicatable {
      public string speak() { return "ring-ding-ding-ding-dingeringeding!, Wa-pa-pa-pa-pa-pa-pow!"; }
  }

  class Communication
  {
      public string communicate(IComunicatable _animal)
      {
          return _animal.speak();
      }
  }
  ```
</details>
<details>
   <summary style="cursor:pointer; text:bold"><b>📂Python : OCP 비준수 코드📂</b> : Cow와 Sheep을 추가하기위해 hey함수의 수정이 필요하다.</summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```python
  class Animal():
      def __init__(self, type):
          self.type = type


  def hey(animal):
      if animal.type == 'Cat':
          print('meow')
      elif animal.type == 'Dog':
          print('bark')


  bingo = Animal('Dog')
  kitty = Animal('Cat')

  # Cow와 Sheep을 추가하기위해 hey함수의 수정이 필요하다.

  hey(bingo)
  hey(kitty)
  ```
</details>
<details>
   <summary style="cursor:pointer; text:bold"><b>📂Python : OCP 준수 코드📂</b> : 추가되는 동물에 대해 hey함수의 수정을 필요로 하지 않는다L</summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```python
  # interface method
  class Animal:
      def speak(self):
          pass


  class Cat(Animal):
      def speak(self):
          print("meow")


  class Dog(Animal):
      def speak(self):
          print("bark")


  class Sheep(Animal):
      def speak(self):
          print("meh")


  class Cow(Animal):
      def speak(self):
          print("moo")


  def hey(animal):
      animal.speak()

  # 추가되는 동물에 대해 hey함수의 수정을 필요로 하지 않는다


  bingo = Dog()
  kitty = Cat()
  sheep = Sheep()
  cow = Cow()

  hey(bingo)
  hey(kitty)
  hey(sheep)
  hey(cow)
  ```
</details>

#### 3). LSP (리스코프 Substitute Principle) 
<p align="center">
    <img src=https://imgur.com/VeeDucl.png width=400px>
</p>

**ⓐ 리스코프 치환 원칙**
* 상위 클래스가 하위 클래스로 치환될때 문제없이 잘 돌아가야한다.
    * 부모에 정의된 메소드를 자식에서 재정의 되는데, 
    자식클래스로 교체하고, 그 재정의된 자식 메소드사용시 문제가 없는지 확인해봐야 한다.
    * we can use any inheriting class in place of the base class.
    * > If S is a subtype of T, 
      > then objects of type T in program may be replaced with objects of type S
      > without altering any of the desirable properties of that program
* 자식 클래스가 부모클래스의 역할을 제대로 수행 못할때. LSP가 못지켜졌다라고 말할 수 있음

조건 : 
    1. Is A 관계가 확실하게 되야한다, 그리고 Is A 관계라도 LSP를 만족하는지 따져봐야한다.
    2. 메소드 매개변수 타입의 "반변성" 제공 : 같거나, 추상화(일반화해야 되야한다)
    3. 메소드 반환 타입의 "공변성" 제공 : 같거나, 특수화 (구체화 Concrete)되야한다.
    4. 그리고 위의 문법적인 조건들 제외하고 논리적인 측면도 보장이 되야한다. 

장점 : 객체지향의 주요 원리인 다형성을 제대로 활용할 수 있다.


**ⓑ 예시**
<details>
   <summary style="cursor:pointer; text:bold"><b>📂LSP BAD 🤪📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs

  class Rectangle
  {
      protected int width;
      protected int height;

      public void setWidth(int width) {
          this.width = width;
      }

      public void setHeight(int height){
          this.height = height;
      }

      public int calculateArea(): int
      {
          return this.width * this.height;
      }
  }

  class Square : Rectangle
  {
      public void setWidth(int width)
      {
          this.width = width;
          this.height = width;
      }

      public void setHeight(int height)
      {
          this.width = height;
          this.height = height;
      }
  }

  class RectangleTest extends TestCase
  {
      public  testCalculateArea()
      {
          shape = /* new Rectangle(); - lets replace by */ new Square();
          shape.setWidth(10);
          shape.setHeight(2);

          this.assertEquals(shape.calculateArea(), 20); // FAILS - 4 != 20

          shape.setWidth(5);
          this.assertEquals(shape.calculateArea(), 10); // FAILS - 25 != 10
      }
  }

  //부모 클래스의 메서드가 작동하는 방식을 변경해서는 안 됩니다.

  //Square 클래스는 Rectangle 클래스에서 상속하면 안 됩니다. 
  //이 두 클래스가 모두 계산 영역을 가질 수 있는 경우 
  //공통 인터페이스를 구현하고 상당히 다르기 때문에 서로 상속하지 않도록 합니다.
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂LSP GOOD 😎📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
interface IICalculableArea
{
    public calculateArea();
}

class Rectangle : ICalculableArea
{
    protected int width;
    protected int height;

    public void __construct(int width, int height)
    {
        this.width = width;
        this.height = height;
    }

    public int calculateArea() {
        return this.width * this.height;
    }
}

class Square : ICalculableArea
{
    protected int edge;

    public void __construct(int edge) {
        this.edge = edge;
    }

    public  calculateArea(){
        return this.edge * this.edge ;
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂LSP가 잘못된 상황📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  public class 망치 {
    void virtual 못을박기() {...}
    void virtual 공구상자에넣기(){/* ... */}
  }

  public class 귀상어_HammerheadShark : 망치(){
    void override 못을박기(){/* ... */}       //귀상어로 못을 박을수가 있나?
    void virtual 공구상자에넣기(){/* ... */}  //귀상어를 공구상자에 넣읗수 있나??
    //사용안할 메소드를 받는게 잘 된건가?
  }

  public class 목공 {
    public void 연결(못, 망치, 나무들){
      만약... 인수 타입이 "귀상어_HammerheadShark"라면?
      귀상어로 망치질 할수 있나?
    }
  }

  static void Main(String argv){
  }
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂LSP 예시📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```python
class Animal:
    def speak(self):
        pass

class Cat(Animal):
    def speak(self):
        print("meow")


class BlackCat(Cat):
    def speak(self):
        print("black meow")

class Fish(Animal) :
    def speak(self):
        raise Exception("Fish cannot speak")

def speak(_animal: Animal):
    _animal.speak()


animal = Cat()
speak(animal);
animal = BlackCat()
speak(animal);
animal = Fish();
speak(animal);
```
</details>

#### 4). ISP (Interface Segregation Principle) ❓

<p align="center">
    <img src=https://imgur.com/MPg0VDj.png width=400px>
</p>

**ⓐ 인터페이스 분리 원칙**

커버져린 인터페이스 사용시 사용하지도 않을 인터페이스가 
클래스로 들어오게 된다면?..

* 뚱뚱한 인터페이스를 사용 해서는 안된다.
  * 클라이언트는 사용하지도 않을 메소드들에게
의존하게 해선 안된다 인터페이스를 더 작은 단위로 나누자
  * ![](https://imgur.com/3fiKwpU.png)
  * 
    ```text
    1. 자동차 인터페이스는 
         * 자동차 인터페이스 클래스만
    2. 보트 인터페이스는 
         *  보트 인터페이스 클래스만
    3. 만약 양육자동차려면
         * 자동차 보트 인터페이스 둘다 가져오기
    ```


**ⓑ 예시**
<details>
   <summary style="cursor:pointer; text:bold"><b>📂ISP 준수 비준수📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```cs
  //No Interface Segregation Principle

  //Large Interface
  interface ICarBoatInterface
  {
  	public void drive();
  	public void turnLeft();
  	public void turnRight();
  	public void steer();
  	public void steerLeft();
  	public void steerRight();
  }

  //Interface Segregation Principle
  //two small interfaces (Car, Boat)
  interface ICarInterface
  {
  	public void drive();
  	public void turnLeft();
  	public void turnRight();
  }

  interface IBoatInterface
  {
  	public void steer() 	{ /*implemenetation*/ }
  	public void steerLeft() { /*implmementation*/ }
  	public void steerRight(){ /*implementation*/ }
  }


  class Avante : ICarInterface
  {
  	public void drive() 	{ /*implemenetation*/ }
  	public void turnLeft() 	{ /*implmementation*/ }
  	public void turnRight()	{ /*implementation*/ }
  }


  class CarBoat :ICarInterface , IBoatInterface
  {
  	public void drive() 	{ /*implemenetation*/ }
  	public void turnLeft() 	{ /*implmementation*/ }
  	public void turnRight()	{ /*implementation*/ }
  	public void steer() 	{ /*implemenetation*/ }
  	public void steerLeft() { /*implmementation*/ }
  	public void steerRight(){ /*implementation*/ }
  }
  ```
</details>


#### 5). DIP (Dependency Inverse Principle) ❓

<p align="center">
    <img src=https://imgur.com/j0xQyAR.png width=400px>
    <img src=https://imgur.com/gkAhmWI.png width=400px>
</p>

**ⓐ 의존 역전 원칙**

* "추상화에 의존하라"
  * 구체적인 개념보다는 추상적인 개념에 의존해야 한다.

* 변동성이 큰 클래스로부터 파생하지 말자, 대신 추상 팩토리로 파생하여 확장성을 높이자
* 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장합니다.

**ⓑ Hook 메소드 란?**
  1. *[1) Virtual 하게 정의]* 해두거나 *[2) 비워진 (추상적으로)]* 수퍼 클래스에 정의된 메소드이며,

* 특정 구현에 대한 종속성을 줄여야 하지만 인터페이스에 의존해야 합니다.

**ⓑ 예시**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂DIP_BAD 🤪📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->

  ```cs
  class DatabaseLogger
  {
      public void logError(string message)
      {
          // ..
      }
  }

  class MailerService
  {
      private DatabaseLogger logger;

      public MailerService(DatabaseLogger logger)
      {
          this.logger = logger;
      }

      public void sendEmail()
      {
          try {
              // ..
          } catch (SomeException exception) {
              this.logger.logError(exception.getMessage());
          }
      }
  }
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂DIP_GOOD 😎📂</b></summary>
   
   <!-- summary 아래 한칸 공백 두어야함 -->

  ```cs
  interface ILogger
  {
      public void logError(string message);
  }

  class DatabaseLogger : ILogger
  {
      public void logError(string message)
      {
          // ..
      }
  }

  class MailerService
  {
      private ILogger logger;

      public MailerService(ILogger logger)
      {
          this.logger = logger;
      }

      public void sendEmail()
      {
          try {
              // ..
          } catch (SomeException exception) {
              this.logger.logError(exception.getMessage());
          }
      }
  }

  /*
  이러한 방식으로 세부 구현이 LoggerInterface 를 구현하는 한 
  데이터베이스의 로그를 원하는 로그로 자유롭게 바꿀 수 있습니다 . 
  이 변경 사항은 MailerService에 의존하지 않고 
  인터페이스에만 의존하기 때문에
  MailerService 를 수정할 필요가 없습니다 .
  */
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Python : DIP_비준수📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```python
  class Cat:
      def speak(self):
          print("meow")


  class Dog:
      def speak(self):
          print("bark")


  class Zoo:
      def __init__(self):
          self.cat = Cat()
          self.Dog = Dog()
          #self.sheep = Sheep()
          #self.cow = Cow()
  ```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Python : DIP_준수📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
  ```python
  class abstract_Animal:
      def speak(self):
          pass


  class Cat(abstract_Animal):
      def speak(self):
          print("meow")


  class Dog(abstract_Animal):
      def speak(self):
          print("bark")

  # 동물원은 전혀 건들 필요 없어진다.


  class Zoo:
      def __init__(self):
          self.animals = []  # 동물 리스트 만들기

      def AddAnimal(self, _animal: abstract_Animal):
          self.animals.append(_animal)

      def speakAll(self):
          for _animal in self.animals:
              _animal.speak()


  zoo = Zoo()
  zoo.AddAnimal(Cat())
  zoo.AddAnimal(Dog())
  zoo.speakAll()
  ```
</details>

#### 6). *추가* : 데메테르의 법칙(Demeter's Law, LoD) 
'친한 친구들 하고만 이야기 하여라' = 동일한 객체 내의 메소드 및 속성을 주로 사용할 것
(SRP와 마찬가지로 결합도를 낮추고 응집도를 끌어올리는 역할을 하게 된다)


---

### 📄 1. 사전 지식

#### 1). 응집도와 결합도.
link : [응집도와 결합도](./응집도_결합도/응집도N결합도.md)

### 📄 2. 디자인패턴 개요
#### 1). 디자인패턴 왜 배우나? 
**통계적으로 발생되는 문제 23개 패턴 <br>읽기쉽게 이해하기쉽고 수정하기쉬운 코드로 만들기 위해**

#### 2). 종류 : 이것중 우리는 일부만 배운다. 
1. **생성** 패턴 : 5
2. **구조** 패턴 : 7
3. **행위** 패턴 : 11

#### 3). 아키텍쳐 패턴 VS 디자인 패턴
* **아키텍쳐 패턴** : 시스템 구조에 대한 가이드 라인 
  * 모듈 & 컴포넌트를 어떻게 배치할지
* **디자인 패턴** : 모듈의 세분화된 역활 & 보듈간의 인터페이스를 상세 구현할때 쓰는 가이드 라인


---


### 📄 3. 생성 패턴

<div align="center">
  <h4> 생성과 참조과정을 캡슐화 하여 객체가 생성되거나 변경되도 <br>
  시스템에 영향을 크게 받지 않도록 프로그램의 유연성을 더해주는 패턴</h4>
</div>

---

#### 1). Singleton pattern

<p align="center">
    <img src=https://imgur.com/XjTKT0I.png width=500px>
</p>


**ⓔ 구성요소**

1. **Application** : 싱글톤에 접근하는 어떠한 아~무 코드
2. **Singletion** : 
    * *private*로 싱글톤 인스턴스가 클래스 내부에 포함된다.
    * *GetInstance()* 로 싱글톤 인스턴스를 static으로 접근한다.

**ⓐ 특징**

1. 전역적으로 접근 가능한 객체라 어디에서든지 참조할 수 있다.
2. ***인스턴스가 오직 단 하나를 상성함을 보장***, 불필요한 메모리 낭비를 최소화 할 수 있다
<p align="center">
    <img src=https://imgur.com/lnKEP8M.png width=500px><br>1. 인스턴스가 하나만 있다. 2. 어디서든 문을 열수있다(어디서든 접근 가능)
</p>

1. 너무 남용하면 다른 클래스의 인스턴스들 간에 결합도가 높아져 개방 폐쇠 원칙이 위배될 수 있다.

**ⓑ 사용하는 이유**

* 전역적으로 사용되는 데이터, 리소스를 수시로 접근해야 할때

* GameManager 힘들게 지정하는 대신 쉽게 Static으로 접근 가능

**ⓒ 다음과 같은 목적에 사용하기를 권한다.**

```text
1. 환경설정 : Audio Manager
2. Save & Load : 단 동기화 문제가 없을시.
3. Camera : 이미 유니티에 Camera.main으로 구현되어있음
4. EventSystem : 사실 이미 유니티에 구현되어 있음
5. Pool : 싱글톤 GameObject를 생성해서 사용. 
  GameLoop가 없는 객체로만.
```

**ⓓ 사용해서는 안되는 상황**

```text
1. 플레이서, 몹, 이펙트
개발 과정에서 결합도가 높아지는 경우가 있음
게다가 Static 변수는 어디서 일어난 버그인지 디버깅 트랙하기 힘들다. 
```

**ⓕ 예시**

**1. 동시성 문제** : *하나만 있어야할 싱글톤 객체가 두번 생성될 수 있는 문제.*
* 싱글톤 생성이 느리면 모든 쓰레드가 거의 동시에 도착하고 이로인해 서로가 null 객체를 바라볼수 있다.
* ***해결책 : Thread-Safe 가 보장되어야 한다.***

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Lazy 기법을 이용한 싱글톤📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
public class LazySingleton {
    private static readonly Lazy<LazySingleton> _instance
        = new Lazy<LazySingleton>(() => new LazySingleton());

    public static LazySingleton Instance {
        get { return _instance.Value; }
        // _instance는 Lazy 객체 이므로 실제 인스턴스는 Value에 있다. 
    }
    private LazySingleton() { }
}
```
</details>

**2. 프레임 드랍 문제** 
* 필요할 때 초기화하는 Lazy 기법. 하지만 전투 도중에 시스템 초기화 작업을 수행한다면 중간에 프레임이 떨어지거나 게임 화면이 뚝뚝 끊길 수도 있다. 
* ***해결책 : 게임 플레이에 영향이 미치지않도록 시작과 동시에 정적 변수를 초기화***

<details>
   <summary style="cursor:pointer; text:bold"><b>📂일반적인 싱글톤 & 오브젝트 풀📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
// 일반적인 싱들톤
public class Singleton {
    private static readonly Singleton _instance = new Singleton();

    public static Singleton Instance {
        get {
            if(_instance == null) return new Singleton();
            return _instance;
        }
    }
}

//GameObject로 사용
public class _className_ : MonoBehavier {
    private static _className_ _instance;

    public static _className_ Instanace {
        get{
            if(_instance == null){ 
                var obj = FindObjectType<_classNmae_>();
                if(obj != null){_instance = obj;}
                else if(obj == null) {
                    var newObj = new GameObject().AddComponent<_className_>();
                    return _instance;
                }
            }
        }
        private set;
    }
}

```
</details>

**3. 실제 유니티 적용 에셋**
* [README](./src/Design/UnityAdaptation/5.%20Singleton/README.md)


---

### 📄 4. 구조 패턴

<div align="center">
  <h4>클래스나 객체를 조합하여 더 큰구조로 만드는 패턴 </h4>
</div>

---

#### 1). Composite Pattern

<p align="center">
  <img src=https://imgur.com/e4BNU5l.png width=500px>
</p>

**ⓐ 쓰는 이유?**
> 컴포지트 패턴은 앱의 핵심 모델을 트리로 나타낼 수 있는 경우에만 의미가 있다.
> 
1. 여러 개체를 동일한 목적으로 사용하고 있으며 각 개체를 처리하는 코드가 거의 동일한 경우 컴포지트를 사용하는 것은 좋은 선택이다.
2. 칼이면 휘두루고, 총이면 방아쇠를 당기는등. 컴포지트와 각기다른 객체의 차이를 무시하고 **어쨌든 공격한다는 점**에서 같은 동작처럼 사용하고 싶을때. <sub>*Composite should be used when clients ignore the difference between compositions of objects and individual objects*</sub>
3. 트리 계층 구조에서 상속이 가지는 문제를 해결해준다. part-whole hierarchies 
4. 컴포지트 패턴은 모든 트리구조의 모든 컴포넌트를 재귀적으로 순회 가능하다.
<p align="center">
    <img src=https://imgur.com/IpZCHYZ.png width=500px><br>
</p>

**ⓑ 구성요소**
|Case 1|Case 2|
|---|---|
|<img src=https://imgur.com/UGFnf8c.png>|<img src=https://imgur.com/YboPsUf.png>|

1. **Component** : 추상클래스 또는 인터페이스다.
2. **Leaf** : *Leaf*는 *Component* 의 파생 클래스이다.
3. **Composite** : 다른건 몰라도... 다음이 포함된다.
    1. Component 인스턴스를 담는 컨테이너 (List, Dictionary)
        ```cs
        private List<Component> components = new List<Component>();
        ```
    2. Component 컨테이너를 추가하거나 삭제하는 메서드
        ```cs
        public addComponent(Component _c) {
          components.Add(_c);
        }
        ```


**ⓑ 예시**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Composite Pattern (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace DesignPattern
{
    internal class Composite {
        public interface Equipment_Composition {
            public void Equip();
            public void Dump();
        }

        public class Weapon_Leaf : Equipment_Composition {
            public void Equip(){/*...*/}
            public void Dump(){/*...*/}
        }
        public class Hat_Leaf : Equipment_Composition {
            public void Equip(){/*...*/}
            public void Dump(){/*...*/}
        }
        public class Body_Leaf : Equipment_Composition {
            public void Equip(){/*...*/}
            public void Dump(){/*...*/}
        }
        public class Accessories_Leaf : Equipment_Composition {
            public void Equip(){/*...*/}
            public void Dump(){/*...*/}
        }
        public class Player : Equipment_Composition {
            Array<Equipment_Composition> Equipments = new Array<Equipment_Composition>();

            public void 줍기(Equipment_Composition _장비){
                Equipments.Add(_장비);
            }

            public override void EquipAll(){
                foreach(Equipment_Composition E in Equipments){
                    E.Equip();
                }
            }
        }

        static void Main(string argv){
            Player Sophia = new Player();
            Weapon_Leaf sword = new Weapon_Leaf(); 
            Body_Leaf 철갑옷 = new Body_Leaf();
            
            Sophia.줍기(sword);
            Sophia.줍기(철갑옷);

            Sophia.EquipAll();
        } 
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Composite Pattern 2 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace DesignPattern
{
    internal class Composite {
        public interface Graphic {
            public void Print();
        }
        public class Ellipse : Graphic {
            static int ellipseNum = 0;
            private int order = 0;
            public Ellipse() {
                order = ellipseNum;
                ellipseNum++;
            }
            public void Print(){ Console.WriteLine($"{this.order} Ellipse"); }
        }

        public class Circle : Graphic {
            static int circleNum = 1;
            private int order = 0;
            public Circle() {
                order = circleNum;
                circleNum++;
            }
            public void Print(){ Console.WriteLine($"{this.order} Circle"); }
        }

        public class CompositeGrapic : Graphic {
            private readonly List<Graphic> graphics = new List<Graphic>();
            public void addGrapic(Graphic G){
                graphics.Add(G);
            }
            public void Print(){
                foreach(Graphic E in graphics){E.Print();}
            }            
        }

        static void Main(string argv){
            CompositeGrapic compositeGrapic = new CompositeGrapic();
            compositeGrapic.addGrapic(new Circle());
            compositeGrapic.addGrapic(new Circle());
            compositeGrapic.addGrapic(new Ellipse());
            compositeGrapic.addGrapic(new Circle());
            compositeGrapic.addGrapic(new Ellipse());
            compositeGrapic.addGrapic(new Ellipse());
            compositeGrapic.addGrapic(new Ellipse());

            compositeGrapic.Print();
        }
    }
}
```
</details>


---

#### 2). Decorator Patterns

<p align="center">
  <img src=https://imgur.com/B7f6iio.png width=500px>
</p>

**ⓐ 특징**
1. 객체의 기본 기능에 추가 기능을 덧붙여 결합 & 장착할 수 있다. 

<p align="center">
  <img src=https://imgur.com/9MLMVyA.png width=500px><br>1. 다수의 옷이 가진 각각의 효과를 결합 할 수 있다.
</p>

1. 즉 객체를 런타임 동안 동적으로 변화시킬수 있다.

**ⓑ 왜 쓰는가?**
* 기능 확장성
  * 기존 코드를 수정하지 않고도 데코레이터 패턴을 통해 행동을 확장할수 있다.
* 동적 확장성
  * 구성과 위임을 통해서 실행중에 새로운 행동을 추가할 수 있습니다.

**ⓒ 구성요소** 

1. **Component**
    * 인터페이스 또는 추상클래스가 된다.
    * 기본 기능을 정의한다.
2. **ConcreteComponent**
    * 기본 기능이 되는 인스턴스가 된다. 데코가 붙을 대상
    * *Component*를 상속한다.
3. **Decorator**
    * 데코가 붙을 대상을 포함한다. 
    * *ConcreteDecorator*의 form을 제공함 ConcreteDecorator가 생긴다면 다 Decorator와 비슷하게 생김
    * 추상클래스다
4. **ConcreteDecorator**
    * 객체에 *ConcreteDecorator*기능을 추가하고싶을때 
    *ConcreteDecorator* 생성자에 객체를 넣는다 그럼 행동이 추가된다.

**ⓓ 단점**
* 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해 질 수 도 있다.  

**ⓔ 예시**
* 클라이언트가 데코레이터를 붙이는 방법
    ```cs
    /* Client.cs */
    Component component = new ConcreteComponent();

    component = new ConcreteDecorator1(...);
    component = new ConcreteDecorator2(...);
    ```

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Decorator Pattern (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using System.Text;

namespace DesignPattern
{
    public abstract class Item
    {
        public abstract int GetLineCount();
        public abstract int GetMaxLength();
        public abstract int GetLength(int i);
        public abstract String GetString(int _i);
        public virtual void PrintString()
        {
            int lineNum = GetLineCount();
            for (int i = 0; i < lineNum; i++)
            {
                String str = GetString(i);
                Console.WriteLine(str);
            }
        }
    }
    public class Strings : Item
    {
        private List<String> strings = new List<String>();

        public void add(String _str)
        {
            strings.Add(_str);
        }
        public override int GetLineCount()
        {
            return strings.Count();
        }
        public override int GetMaxLength()
        {
            int maxLen = 0;
            foreach (String E in strings)
            {
                maxLen = maxLen < E.Length ? E.Length : maxLen;
            }
            return maxLen;
        }
        public override int GetLength(int i)
        {
            return strings[i].Length;
        }
        public override String GetString(int i)
        {
            return strings[i];
        }
    }
    public abstract class Decorator : Item
    {
        protected Item item;
        public Decorator(Item item)
        {
            this.item = item;
        }
    }
    public class SideDecorator : Decorator
    {
        private readonly Char decoChar = ' ';
        public SideDecorator(Item item, Char _c) : base(item)
        {
            decoChar = _c;
        }
        public override int GetLineCount()
        {
            return item.GetLineCount();
        }
        public override int GetMaxLength()
        {
            return item.GetMaxLength() + 2;
        }
        public override int GetLength(int i)
        {
            return item.GetLength(i) + 2;
        }
        public override String GetString(int i)
        {
            return decoChar + item.GetString(i) + decoChar;
        }
    }
    public class BoxDecorator : Decorator
    {

        public BoxDecorator(Item item) : base(item) { }
        public override int GetLineCount()
        {
            return item.GetLineCount() + 2;
        }
        public override int GetMaxLength()
        {
            return item.GetMaxLength() + 2;
        }
        public override int GetLength(int i)
        {
            return item.GetLength(i) + 2;
        }
        public override String GetString(int i)
        {
            int maxLen = GetLineCount();
            if (i == 0 || i == maxLen - 1) { return MakeBorder(); }
            return $"|{MakeTailString(item.GetString(i - 1))}|";
        }
        String MakeBorder()
        {
            int maxLen = GetMaxLength();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < maxLen; i++)
            {
                if (i == 0 || i == maxLen - 1) { sb.Append('+'); continue; }
                sb.Append('-');
            }
            return sb.ToString();
        }
        string MakeTailString(string _target)
        {
            int maxLen = item.GetMaxLength();
            int spaceLen = maxLen - _target.Length;
            for (int i = 0; i < spaceLen; i++) { _target += ' '; }
            return _target;
        }
    }
    public class LineNumberDecorator : Decorator
    {

        public LineNumberDecorator(Item item) : base(item) { }
        public override int GetLineCount()
        {
            return item.GetLineCount();
        }
        public override int GetMaxLength()
        {
            return item.GetMaxLength() + 4;
        }
        public override int GetLength(int i)
        {
            return item.GetLength(i) + 4;
        }
        public override String GetString(int i)
        {
            return $"{String.Format("{0,2:D2}", i)} :{item.GetString(i)}";
        }
    }

    static void Main(string[] argv)
    {
        Strings strings = new Strings();
        strings.add("Hello~");
        strings.add("My name is escatrgot");
        strings.add("I am a Game and Web Developer");
        strings.add("Right now im learning DesignPattern !!");
        strings.PrintString();
        Item decorator = new SideDecorator(strings, '/');
        decorator = new BoxDecorator(decorator);
        decorator = new LineNumberDecorator(decorator);
        decorator = new BoxDecorator(decorator);
        decorator = new LineNumberDecorator(decorator);
        decorator.PrintString();
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Decorator Pattern 2(C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace DesignPattern
{
    internal class Decorator {
        interface Attackable {
            public void Attack();
        } 

        public class Player : Attackable {
            public void Attack(){
                Console.WriteLine("평타");                
            }            
        } 

        public abstract class Decorator : Attackable {
            protected Attackable attackable;
            public Decorator(Attackable attackable){
                this.attackable = attackable;
            }
        }

        public class Laser : Decorator {
            public override void Attack(){
                attackable.Attack();
                Console.WriteLine("찌유유유웅");       
            }
        }

        public class Knife : Decorator {
            public override void Attack(){
                attackable.Attack();
                Console.WriteLine("슉 슈슈슉 ㅅ벌럼아 칼협 칼협");       
            }
        }

        public class Screem : Decorator {
            
            public override void Attack(){
                attackable.Attack();
                Console.WriteLine("喝!!!!!!!!!!!!!!!!!!!!!!!!");
            }
        }
        
        static void Main(string[] argv){
            Player player = new Player();
            player.Attack();

            Attackable decorator = new Laser(player);
            decorator.Attack();
            decorator = new Knife(decorator);
            decorator.Attack();
            decorator = new Laser(decorator);
            decorator = new Screem(decorator);
            decorator.Attack();
        }
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Decorator Pattern 3(C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
namespace DesignPattern
{
    public interface Component
    {
        public String add();
    }

    public class 에스프레소 : Component {
        String name = "에스프레소";
        public String add() {
            return name;
        }
    }

    public abstract class CoffeeDecorator : Component{
        protected readonly Component coffeeComponent;
        public CoffeeDecorator(Component component){
            this.coffeeComponent = component;
        }
        public virtual String add()
        {
            return coffeeComponent.add();
        }
    }
    public class 물데코레이터 : CoffeeDecorator
    {
        public 물데코레이터(Component component) : base(component) { }
        public override String add() { return $"{coffeeComponent.add()} + 물"; }
    }
    public class 우유데코레이터 : CoffeeDecorator {
        public 우유데코레이터(Component component) : base(component){}
        public override String add() { return $"{coffeeComponent.add()} + 우유"; }
    }
    public class 얼음데코레이터 : CoffeeDecorator
    {
        public 얼음데코레이터(Component component) : base(component) { }
        public override String add() { return $"{coffeeComponent.add()} + 얼음"; }
    }
    public class 휘핑크림데코레이터 : CoffeeDecorator
    {
        public 휘핑크림데코레이터(Component component) : base(component) { }
        public override String add() { return $"{coffeeComponent.add()} + 휘핑크림"; }
    }
    public class 자바칩데코레이터 : CoffeeDecorator
    {
        public 자바칩데코레이터(Component component) : base(component) { }
        public override String add() { return $"{coffeeComponent.add()} + 자바칩"; }
    }
    static void Main(string[] argv)
    {
        Component espresso = new 에스프레소();
        Console.WriteLine($"espresso : {espresso.add()}");
        Component americano = new 물데코레이터(espresso);
        Console.WriteLine($"americano : {americano.add()}");
        Console.WriteLine($"espresso : {espresso.add()}");
        Component latte = new 우유데코레이터(new 에스프레소());
        Console.WriteLine($"latte : {latte.add()}");

        Component 자바칩프라푸치노 = new 자바칩데코레이터(new 휘핑크림데코레이터(new 얼음데코레이터(latte)));
        Console.WriteLine($"자바칩프라푸치노 : {자바칩프라푸치노.add()}");
    }
}
```
</details>

* [Decorator Unity](./src/Design/UnityAdaptation/20.%20Decorator/README.md)

#### 3). Flyweight Pattern

<p align="center">
  <img src=https://imgur.com/ksNYupU.png width=700px>
</p>

**ⓐ 특징**
* 다수의 유사객체를 사용하거나 조작할떄 유용
* 인스턴스가 필요할 때마다 매번 생성하는것이 아닌 가능한 공유를 통해 사용함으로 메모리를 절약하는 패턴
* 인스턴시에이트를 많이 해야할때, 공유를 통해 오브젝트를 더 가볍게, 메모리를 절약할때 사용한다.

**ⓑ 왜 쓰는건가?**
* 마인크래프트를 생각해보자 매~~~~~~우 많은 블럭들이 있을것이다. 이 마크에서는 텍스쳐를 플라이 웨이트방식으로 구현했다
* 만약 스타같은 게임을 만든다할때. 유닛들은 같은 mesh, texture, maxhelth setting등등
이 유닛들이 모두 단일 오브젝트를 받아 공유되게끔 만들수 있다.
* 유니티에서도 이미 sharedMesh, sharedMaterial으로 구현되어 있다. 하나 바꾸면 다 바뀌게

**ⓒ 구현**
* 모든 인스턴스에서 공유할 수 있는 데이터를 분할시킨다. 
* Storage 클래스를 만들어 공유데이터를 넣고, 불러오는 방식

---

### 📄 5. 행동 패턴

<h4 align="center">
클래스와 객체간 서로 상호작용하는 방법이나 책임 분배 방법을 정의
하나의 객체로 수행할 수 없는작업을 여러 객체로 분해하면서 결합도를 낮출수 있음
</h4>
 
#### 1). ✨ Command Pattern✨

<p align="center">
  <img src=https://imgur.com/2F8WBc4.png width=500px><br>
  <img src=https://imgur.com/8fuUV9V.png width=500px>
</p>

**ⓐ 특징**

* 커맨드 : **"함수를 추후에 불러낼(요청할)수 있는 형태"** 객체를 의미한다. 
  * 함수 이름, 함수를 보유하고 있는 객체, 그 함수에 사용될 인수 같은 정보를 가지고 
* ***"함수 호출(요청)"*** 를 인스턴스화 하는 패턴이다. 
  * 함수 호출을 객체로 감싼다는 것이므로 콜백을 객체지향적으로 표현한 것
* Invoke을 시킬 수 있고, 취소할 수 있다.

절차
1. Caller 인보커에 트리거가 들어가면
2. 트리거에 컴포넌트된 excute 함수를 실행시켜
3. excute 함수에 컴포넌트된 리시버 함수가 실행


**ⓑ 왜 쓰는건가?**

1. 커맨드를 이용해 캡슐화 하여 재사용성이 높은 클래스설계할 수 있다.

2. 리플레이 시스템
    * 각 업데이트마다 했던 호출된 함수(메서드) 로그를 남긴다.
    * 그 커맨드(함수호출)들은 이터레이트 가능
    * undo와 redo 시스템을 구현할 수 있다.
3. 입력 키 변경

**ⓒ 구성요소**
* **Command** : 
  * 적어도 ConcreteCommand면 가져야할 것을 정의하는 상위클래스
  * execute(actor) 함수를 가지는 **인터페이스 || 추상클래스**
* **ConcreteCommand** : 클래스명은 행동에대한 동사형 적기 (Ex. TurnTvOn, JumpCommand) 
  * 이제 *행동 A호출*이라는것을 구현한 클래스이다.
  * Command에서 파생됨
  * 리시버를 포함하고 리시버의 매소드를 사용한다., 생성자를 받아 Receiver을 초기화해주자.
  * 커맨드가 어떻냐 조건에 따라 호출할 행동을 작성
* **Receiver** :
  * 행동 A에 대한 로직을 가지고 있다.
  * 행동 A는 커맨드에서 사용된다.
* **Caller || Invoker** :
  * 선택적으로 커맨드 execution을 보류할 수 있고,
  * 커맨드실행을 한다.


**ⓓ 예시**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Undo Command (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
namespace DesignPattern
{
    //Base class for the commands
    //This class should always look like this to make it more general, so no constructors, parameters, etc!!!
    public abstract class Command
    {
        public abstract void Execute();
        public abstract void Undo();
    }   
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Command Pattern 정석적인 예시 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
namespace DesignPattern
{
    public interface ElectronicDevice
    {
        public void On();
        public void Off();
        public void VolumeUp();
        public void VolumeDown();
    }

    //리시버
    public class Television : ElectronicDevice {
        private int volume = 0;
        public void On(){
            Console.WriteLine("TV is On");
            }
        public void Off(){
            Console.WriteLine("TV is Off");
            }
        public void VolumeUp(){
            this.volume++;
            Console.WriteLine($"TV Volume is at {this.volume}");
            }
        public void VolumeDown(){
            this.volume--;
            Console.WriteLine($"TV Volume is at {this.volume}");
            }
    }

    //리시버
    public class Radio : ElectronicDevice {
        private int volume = 0;
        public void On(){
            Console.WriteLine("Radio is On");
            }
        public void Off(){
            Console.WriteLine("Radio is Off");
            }
        public void VolumeUp(){
            this.volume++;
            Console.WriteLine($"Radio Volume is at {this.volume}");
            }
        public void VolumeDown(){
            this.volume--;
            Console.WriteLine($"Radio Volume is at {this.volume}");
            }
    }

    //커맨드
    public interface Command {
        public void Execute();
    }

    //콘크리트 커맨드
    public class TurnTvOn : Command {
        private ElectronicDevice electronicDevice;
        public TurnTvOn(ElectronicDevice electronicDevice){
            this.electronicDevice = electronicDevice;
        }

        public void Execute(){
            electronicDevice.On();
        }
    } 

    //콘크리트 커맨드
    public class TurnTvOff : Command {
        private ElectronicDevice electronicDevice;
        public TurnTvOff(ElectronicDevice electronicDevice){
            this.electronicDevice = electronicDevice;
        }

        public void Execute(){
            electronicDevice.Off();
        }
    }

    public class TurnAllDevices : Command {
        List<ElectronicDevice> electroDevices;
        public TurnAllDevices() {
            this.electroDevices = new List<ElectronicDevice>();
        }
        public TurnAllDevices AddDevices(ElectronicDevice electronicDevice){
            this.electroDevices.Add(electronicDevice);
            return TurnAllDevices;
        }

        public void Execute(){
            foreach(ElectronicDevice E in this.electroDevices){E.Off();}
        }
    }

    //콜러 || 인보커
    public class DeviceButton{
        Command theCommand;
        public DeviceButton(Command command){
            this.theCommand = command;
        }
        public void Press(){
            theCommand.Execute();
        }
    }

    static void Main(string argv) {
        ElectronicDevice tv = new Television();

        TurnTvOn onCommand = new TurnTvOn(tv);
        TurnTvOff offCommand = new TurnTvOff(tv);

        DeviceButton onButton= new DeviceButton(onCommand);

        onButton.Press();
        onButton = new DeviceButton(offCommand);
        onButton.Press();

        ElectronicDevice radio = new Radio();

        TurnAllDevices allOffCommand= new TurnAllDevices();
        allOffCommand.AddDevices(radio).AddDevices(tv);

        onButton = new DeviceButton(allOffCommand);
        onButton.Press();
    }
} 
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Command Pattern 키 변경 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System.Collections;
using UnitEngine;

namespace DesignPattern
{
    public interface CommandKey {
        public void Execute(GameObject obj);
    }

    public class CommandAttack : CommandKey {
        public void Execute(Gameobject obj) { Attack(obj); }
        void Attack(Gameobject obj){
            obj.transform.Translate(Vector3.forword);
        }
    }
    public class CommandDefense : CommandKey {
        public void Execute(GameObject obj){ Defense(obj);	 }

        void Defense(GameObject obj)
        {
            Debug.Log(obj.name + " Defense");
            obj.transform.Translate (Vector3.back);
        }
    }

    public class csPlayerCommand : MonoBehaviour {
        CommandKey btnA, btnB;

        void Start () { SetCommand(); }

        void SetCommand()
        {
            btnA = new CommandAttack();
            btnB = new CommandDefense();
        }

        public void BtnCommandA()
        {
            btnA.Execute(gameObject); // 이 스크립트가 붙은 오브젝트를 공격하게 함
        }
        public void BtnCommandB()
        {
            btnB.Execute(gameObject); // 이 스크립트가 붙은 오브젝트를 방어하게 함
        }

    }
} 
```
</details>

* [Command Unity](./src/Design/UnityAdaptation/1.%20Command/README.md)

**ⓔ 참고**
* 명령 패턴을 쓰다보면 수많은 Command 클래스를 만들어야 할 수 있다. 이럴 때에는 상위 클래스에 여려 가지 편의를 제공하는 상위 레벨 메서드를 만들어 놓은 뒤에 필요하면 하위 클래스에서 원하는 작동을 재정의할 수 있게 하면 좋다. 이러면 명령 클래스의 execute 메서드가 하위 클래스 샌드박스 패턴으로 발전하게 된다.


#### 2). ✨ Observer Pattern✨

<p align="center">
  <img src=https://imgur.com/fUCfWzC.png width=450px>
  <img src=https://imgur.com/L2h6Axq.png width=450px>
</p>

<h4 align="center">✨매우 중요하므로 대리자 & 이벤트 에서 정리✨</h4>

**ⓐ 특징**
* 이벤트기반 패턴이다. 디커플링에 매우 유용           
* 옵서버 패턴은 여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 메커니즘을 정의할 수 있도록 하는 행동 디자인 패턴입니다.

**ⓑ 왜 쓰는가?**
* 옵서버 패턴은 한 객체의 상태가 변경되어 다른 객체들을 변경해야 할 필요성이 생겼을 때, 그리고 실제 객체 집합들을 미리 알 수 없거나 이러한 집합들이 동적으로 변경될 때 사용하세요.
  
* 손님들이 신제품 출시 확인을 위해 시간을 낭비하든지, 매장들이 알림을 원하지 않는 고객들에게 신제품 출시를 알리는 이 두가지 문제를 어떻게 해결할까?
<p align="center">
  <img src=https://imgur.com/MnbJolt.png width=500px>
  <br>1. 아이폰이 출시될 예정이라는 얘기를 듣고 가게에 들어왔나 안들어왔나 왔다갔다하면서 뻉이 치는중<br>2. 아이폰 출시를 모두한테 알리는데, 만약 관심 없는 사람한테도 알림이 간다면? 스팸메일이 될것이다.
</p>

**ⓒ 구성요소**

<p align="center">
  <img src=https://imgur.com/Ev0OpLc.png width=500px>
</p>


* **Subject = Publisher** : 
  * 시간이 지나면 병경 될 수 있는 객체
  * 자신의 상태에 변경에 대해서 다른 객체들에게 알림을 보내는 역할도 한다.
  * Observer(Subscriber) 리스트를 가지고 있다.
    * 이벤트가 발생할 때 마다 Observer(Subscriber) 리스트를 참조한다
  * Observer(Subscriber) 가 구독 또는 구독 취소를 할 수 있는 매커니즘을 가진 구독자 객체

* **Observer = Subscriber** :
  * Subscriber(Publisher)가 만드는 알림을 받는 객체
  * 알림을 받으면 실행될 Update를 가진 인터페이스로 구현한다.
  * 이 객체를 상속받으면 ConcreteObserver(ConcreteSubscriber)가 된다.

* **클라이언트**
  * 클라이언트는 Subject 와 Observer 객체를 별도로 생성하고 Observer를 Subject에 등록한다.

**ⓓ 예시**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂Observer Pattern 정석적인 예시 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace DesignPattern
{
    /*
    *
    */
    interface Observer {
        public void Update();
    }

    class Subject {
        List<Observer> mObservers = new List<Observer>();

        public void Register(Observer _observer) {
            mObservers.Add(_observer);
        }

        public void Unregister(Observer _observer){
            mObservers.Remove(_observer);
        }

        public void AlertToObservers(){
            foreach(Observer E in mObservers){E.Update();}
        }
    }

    /*
    * Concrete
    */
    class ConcreteObserver_Cat : Observer {
        public void Update() {
            Console.WriteLine("Meow");
        }
    }
    class ConcreteObserver_Dog : Observer {
        public void Update() {
            Console.WriteLine("Bark");
        }
    }
    class Owner : Subject {}
    /*
    * Client.cs
    */
    static void Main(string argv){
        Owner owner = new Owner();
        ConcreteObserver_Cat cat = new ConcreteObserver_Cat();
        ConcreteObserver_Dog dog = new ConcreteObserver_Dog();

        owner.Register(cat);  owner.Register(dog);
        owner.AlertToObservers();
        owner.Unregister(cat);
        owner.AlertToObservers();
    } 
}
```
</details>
<details>
   <summary style="cursor:pointer; text:bold"><b>📂Observer Pattern 홀짝 게임 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace DesignPattern
{
    public abstract class Observer_Player {
        private String name;

        public Observer_Player(String _name) {
            this.name = _name;
        }

        public String Name {get{return this.name;}}

        public abstract void Update(int diceNumber);
    }

    public abstract class Subject_DiceGame {
        protected List<Observer_Player> playerList = new List<Observer_Player>();

        public void AddPlayer(Observer_Player player){
            playerList.Add(player);
        }

        public abstract void Play();
    }

    public class ConcreteSubject_FairDiceGame : Subject_DiceGame {
        private Random random = new Random();

        public override void Play()
        {
            int diceNumber = random.Next(6) + 1;
            Console.WriteLine($"주사위눈 : {this.diceNumber}");

            foreach(Observer_Player E in playerList){
                E.Update(diceNumber);
            }
        }
    }

    public class ConcreteObserver_EvenBattingPlayer : Observer_Player
    {
        public ConcreteObserver_EvenBattingPlayer(String _name) : base(_name) { }
        public override void Update(int diceNumber)
        {
            if (diceNumber % 2 == 0) { Console.WriteLine("짝수 당첨"); }
        }
    }
    public class ConcreteObserver_OddBattingPlayer : Observer_Player
    {
        public ConcreteObserver_OddBattingPlayer(String _name) : base(_name) { }
        public override void Update(int diceNumber)
        {
            if (diceNumber % 2 != 0) { Console.WriteLine("홀수 당첨"); }
        }
    }

    public static void main(String[] args){
        Subject_DiceGame diceGame = new ConcreteSubject_FairDiceGame();

        ArrayList<Observer_Player> player = new ArrayList<Observer_Player>();
        player.Add(new ConcreteObserver_EvenBattingPlayer("짝궁둥이"));
        player.Add(new ConcreteObserver_OddBattingPlayer("홀아비"));
        player.Add(new ConcreteObserver_OddBattingPlayer("홀쭉이"));

        foreach(Observer_Player E in player){
            diceGame.AddPlayer(E);
        }

        for(int i = 0; i< 5; i++){
            diceGame.Play();
            Console.WriteLine();
        }
    }
}
```
</details>

* [Observer Unity](./src/Design/UnityAdaptation/3.%20Observer/README.md)

**ⓔ Unity also has its own implementation.** 
1. EventHandler 2. Action 3. UnityEvent 4. delegate
2. 자기 자신과 관계없는 함수와 연결시켜줄 수 있다.

#### 3). State Pattern

<p align="center">
  <img src=https://imgur.com/m8LqFmq.png width=500px><br>
  <img src=https://imgur.com/bG8DnCW.png width=500px>
</p>

**ⓐ 특징**

* **"상태"를 객체화한 패턴이다**. 이 상태라는것도 참조가능하다.
* 상태에 따라 객체의 행위 내용을 변경해주는 패턴
  * 메인 캐릭터가 가질만한 상태를 생각해보자. jump, walk, run 등등..
이러한 상태를 손쉽게 switcing 하고 싶을떄. 제안하는 패턴이다.
* 오토마타의 state machine와 관련이 깊다.
  * [FSM 유한상태기계의 기초 & 유니티 설계 이론.](../..//Math/FSM.md)

**ⓑ 왜 쓰는가?**

* if 조건절이 많을때 사용하면 유용하다.
* 객체의 상태에 따라 동일한 동작을 다르게 처리해야할떄,
  ```text
  1. Menu System : 메뉴 UI
  2. 미니게임
  3. 인트로 영상
  4. Animatior : 실제 유니티의 animatior에 구현이 되어있다.
  5. 몬스터의 AI 만들기
  ```

<p align="center">
  <img src=https://imgur.com/DJhMotZ.png width=500px>
</p>


**ⓒ 구성요소**
* **State** : 
  * 상태 전이를 시키는 ***상태전이 함수(handle)*** 를 추상화하여 ConcreateState가 파생되도록
* **ConcreateState** 
  * State를 상속받고, ***상태전이 함수(handle)*** 를 구체화 한다.
  * 그리고 이 객체 자체가 ***상태*** 가된다.
* **Context || Player**
  * Player는 State 객체를 포함하고 있다.
  * player.state = new ConcreateState()를 통해
  * ***상태 (ConcreateState)*** 로 전이한다.


**ⓓ 예시**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂신호등 State (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
namespace DesignPattern
{
    enum Estate{ GREEN, YELLOW, RED}
    //enum I{}
    /* 다음은 안좋은 예시
    public class TrraficLight {
        private State mState;
        public TrraficLight(State _s){ this.state = _s; }
        public State state {get; set;} 
        public void Speak(State _s){
            if(_s == GREEN){Console.WriteLine("green light");}
            else if(_s == RED){Console.WriteLine("red light");}
        }

        public void Wait(State _s){
            Console.WriteLine("Wait.. the light changed");
            if(_s == GREEN){Console.WriteLine("green light");}
            else if(_s == RED){Console.WriteLine("red light");}
        }
    }
    */

    public class TrraficLight {
        private State mState;
        public State state {get; set;} 
        
        public TrraficLight(State _s){
            this.state = _s;
        }
        public void Speak(){
            this.state.Speak();
        }
        public void Wait(){
            this.state.Wait();
        }
    }

    public interface State {
        public void Speak();
        public void Wait(TrraficLight _trraficLight);
    }

    public class GreenLight : State {
        public void Speak(){Console.WriteLine("green light");}
        public void Wait(TrraficLight _trraficLight){
            _trraficLight.state = RedLight;//바뀌어질 상태
            Console.WriteLine("wait.. the light changed");
        }
    }
    public class RedLight : State {
        public void Speak(){Console.WriteLine("red light");}
        public void Wait(TrraficLight _trraficLight){
            _trraficLight.state = GreenLight;//바뀌어질 상태
            Console.WriteLine("wait.. the light changed");
        }
    }
    //서로 상태 클래스는 서로 각각 상태클래스를 알고있다.
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂서있기, 앉기, 걷기, 달리기 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using System;
using System.Collections;
using System.Collections.Generic;
namespace DesignPattern
{
    public class Player
    {
        public Player() { speed = 0;  state = new StateStandUp(this); }
        public int speed { get; set; }
        public State state { get; set; }

        public void Talk(String _msg)
        {
            Console.WriteLine($"플레이어의 말 : {_msg}");
        }
    }

    //플레이어에 대한 State 객체 작성
    public abstract class State
    {
        protected Player player;
        public State(Player _player)
        {
            this.player = _player;
        }

        public abstract void StandUp();
        public abstract void SitDown();
        public abstract void Walk();
        public abstract void Run();
        public abstract String GetDescription(); //현재 상태 반환
    }


    public class StateStandUp : State
    {
        public StateStandUp(Player _player) : base(_player) { }

        public override void StandUp() { player.Talk("언제 음직일꺼야?"); }
        public override void SitDown() { 
            player.Talk("앉으니깐 좋다.");
            player.state = new StateSitDown(player);
        }
        public override void Walk()
        {
            player.speed = 5;
            player.state = new StateWalk(player);
            player.Talk("걷기 시작.");
        }
        public override void Run()
        {
            player.speed = 20;
            player.state = new StateRun(player);
            player.Talk("갑자기?? 존나뛰어.");
        }
        public override String GetDescription()
        {
            return "지금은 서있는 상태";
        }
    }
    public class StateSitDown : State
    {
        public StateSitDown(Player _player) : base(_player) { }
        public override void StandUp()
        {
            player.state = new StateStandUp(player);
            player.Talk("일어나자.");
        }
        public override void SitDown()
        {
            player.Talk("쥐나겠다.");
        }
        public override void Walk()
        {
            player.speed = 1;
            player.state = new StateStandUp(player);
            player.Talk("어떻게 앉은상태에서 걷냐? 일단 서있자");
        }
        public override void Run()
        {
            player.speed = 1;
            player.state = new StateStandUp(player);
            player.Talk("어떻게 앉은상태에서 뛰냐 일단 서있자");
        }
        public override String GetDescription()
        {
            return "앉아있음";
        }

    }
    public class StateWalk : State
    {
        public StateWalk(Player _player) : base(_player) { }
        public override void StandUp()
        {
            player.speed = 0;
            player.state = new StateStandUp(player);
            player.Talk("멈춰..");
        }
        public override void SitDown()
        {
            player.speed = 0;
            player.state = new StateSitDown(player);
            player.Talk("걷다가 앉으면 넘어질 수 있다.");
        }
        public override void Walk()
        {
            player.Talk("난 걷는걸 좋아하지");
        }
        public override void Run()
        {
            player.speed = 20;
            player.state = new StateRun(player);
            player.Talk("슬슬 뛴다.");
        }
        public override String GetDescription()
        {
            return "걷는 중";
        }
    }
    public class StateRun : State
    {
        public StateRun(Player _player) : base(_player) { }
        public override void StandUp()
        {
            player.speed = 0;
            player.state = new StateStandUp(player);
            player.Talk("뛰다가 갑자기 멈춰?? 연골 나가요.");
        }
        public override void SitDown()
        {
            player.speed = 0;
            player.state = new StateSitDown(player);
            player.Talk("뛰다가 어떻게 앉노.. 미쳤나");
        }
        public override void Walk()
        {
            player.speed = 5;
            player.state = new StateWalk(player);
            player.Talk("속도 줄인다~");
        }
        public override void Run()
        {
            player.speed += 2;
            player.state = new StateRun(player);
            player.Talk("더 빨리 뛰라고? ㅇㅋ");
        }
        public override String GetDescription()
        {
            return "달리는 중";
        }
    }
    static void StateMain()
    {
        Console.WriteLine("[1] : 서있기 | [2] : 앉기 | [3] : 걷기 | [4] : 뛰기 | [5] : 상태 출력 | [0] : 종료");
        Player player = new Player();
        bool stop = false;
        while (!stop)
        {
            var Input = Console.ReadLine();

            try
            {
                var validValue = Input;
            }
            catch
            {
                Console.WriteLine("You did not enter a valid format.");
                Console.ReadLine();
            }

            switch (Input)
            {
                case "1":
                    player.state.StandUp();
                    break;
                case "2":
                    player.state.SitDown();
                    break;
                case "3":
                    player.state.Walk();
                    break;
                case "4":
                    player.state.Run();
                    break;
                case "5":
                    Console.WriteLine(player.state.GetDescription());
                    break;
                case "0":
                    Console.WriteLine("프로그램 종료");
                    stop = true;
                    return;
                default:
                    break;
            }
        }
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂자전거 타기 (C#)📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
namespace DesignPattern{
    public enum Direction {
        Left = -1, Right = 1        
    }   
    public interface IBikeState {
        void Handle(BikeController bikeController);
    }

    public class BikeStateContext {
        public IBikeState currentState {get; set;}
        private readonly BikeController mBikeController;

        public BikeStateContext(BikeController _bikeController){
            this.mBikeController = _bikeController;
        }

        public void Transition(IBikeState _state){
            currentState = _state;
            currentState.Handle(mBikeController);
        }
    }
    /*BikeController.cs*/
    public class BikeController : MonoBehaviour {
        [field : SerializeField] public float maxSpeed {get; private set;} = 2.0f;
        [field : SerializeField] public float turnDistance {get; private set;} = 2.0f;
        public float currentSpeed {get;set;}
        public Direction currentTurnDirection {get; private set;}

        private IBikeState mStartState;
        private IBikeState mStopState;
        private IBikeState mTurntState;

        private BikeStateContext mBikeStateContext;
        private void Awake() {
            mBikeStateContext = new BikeStateContext(this);
            mStartState = gameobject.AddComponent<BikerStateState>();
            mStopState = gameobject.AddComponent<BikerStopState>();
            mTurntState = gameobject.AddComponent<BikerTurnState>();
            mBikeStateContext.Transition(mStopState);
        }
        
        public void StartBike()
        {
            mBikeStateContext.Transition(mStartState);
        }

        public void StopBike()
        {
            mBikeStateContext.Transition(mStopState);
        }

        public void Turn(Direction direction)
        {
            urrentTurnDirection = direction;
            mBikeStateContext.Transition(mTurntState);
        }

    }
    /*ClientState.cs*/
    public class ClientState : MonoBehaviour {
        private BikeController mBikeController;
        private void Awake(){
            MonoBehaviour = GetComponent<BikeController>();
        }

        private void OnGUI(){
            if (GUILayout.Button("Start Bike"))
            {
                mBikeController.StartBike();
            }

            if (GUILayout.Button("Turn Left"))
            {
                mBikeController.Turn(Direction.Left);
            }

            if (GUILayout.Button("Turn Right"))
            {
                mBikeController.Turn(Direction.Right);
            }

            if (GUILayout.Button("Stop Bike"))
            {
                mBikeController.StopBike();
            }
        }
    }
}
```
</details>

* [State Unity](./src/Design/UnityAdaptation/6.%20State/README.md)



---

### 📄 6. 그밖에 Unity에 유용한 패턴

#### 1). ✨ Subclass Sandbox ✨ : Behavioral Patterns

<p align="center">
  <img src=https://imgur.com/JVN9LDY.png width=500px>
  <h4>상위 클래스가 제공하는 기능들을 통해서 하위 클래스에서 행동을 정의한다.</h4>
</p>


**ⓐ 특징**

\# abstract & override #protected #subclass

1. 실제 구현부, 메인이 되는 객체가 파생클래스다.
2. 그럼 상위클래스가 제공하는것은 뭔가? 
   * 상위 클래스는 하위 클래스가 필요로 하는 기능을 전부 제공할 수 있다.
   * 상위 클래스는 하위 클래스용 메소드인 **Sandbox 메소드**를 제공한다.

3. ***sandbox*** 가 의미하는것.
    * 추상 원시 메소드.
    * protected로 만들어져 하위 클래스용이라는 걸 분명히 한다.
    * 하위 클래스에서 구현할때 아무 코드나 넣으면서 마음대로 구현할 수 있다.

**ⓑ 왜 쓰는건가?**

\# decouping #재사용성

***샌드박스 패턴은 이럴 때 좋다. :***

1. ***클래스 하나를 잡고 많이 상속해야할때***
   * 유사한 클래스들을 파생클래스로 구현해야할때
2. 하위 클래스 한번 훑는데 어? 은근 기능 겹치는게 많음, 
겹치는 기능을 상위 클래스로 올려보내
하위 클래스끼리 쉽게 공유하고 싶을때. 
그럼으로 ***상위클래스는 하위클래스가 수행해야할 동작을 전부 제공*** 한다.

3. ***외부 코드간 커플링 감소***
커플링을 상위 클래스에 몰아 놓아 하위 클래스가 필요로 하는 모든 기능을 상위 클래스에서 제공한다. 
   * 하위 클래스는 상위 클래스와만 커플링 될 뿐, 그 외 외부 시스템에는 전혀 접근하지 않는다.
   * 즉, 상위 클래스 외 다른 잡다한 외부 코드를 끌어들일 필요가 없다는 얘기 오직 소통해도 상위 클래스로만 소통한다

**ⓒ 주의 사항**
컴포지트 패턴에서 지적한 상속의 문제
1. 상위 클래스에 코드가 계속 쌓이는 경향이 있다. 특히 하위 클래스 샌드박스 패턴에서는 그럴 여지가 많다.

2. '깨지기 쉬운 상위 클래스' 문제

**ⓒ 구현**

<details>
   <summary style="cursor:pointer; text:bold"><b>📂메서드를 직접 제공📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace SubclassSandbox
{
    //Superclass
    public abstract class Superpower
    {        
        //Active 함수는 서브클래스에서 상속받아 사용될 Sandbox 매소드다.
        public abstract void Activate();

        //이 클래스들은 이제 서브클래스에서 지지고 볶을수 있는 매소드다
            //정말 상위클래스는 하위클래스에게 모든걸 주는구나 = 하위클래스는 오직 상위 클래스간 커플링이 있구나.
        protected void Move(float speed) { Debug.Log("Moving with speed " + speed); }

        protected void PlaySound(string coolSound) { Debug.Log("Playing sound " + coolSound);}

        protected void SpawnParticles() {/*...*/}
    }


    //Subclasses
    public class SkyLaunch : Superpower
    {
        //본격적으로 상속받은 샌드박스 메소드를 구체화 한다.
        public override void Activate()
        {
            //Add operations this class has to perform
            Move(10f);
            PlaySound("SkyLaunch");
            SpawnParticles();
        }
    }

    //Subclasses
    public class GroundDive : Superpower
    {
        //Has to have its own version of Activate()
        public override void Activate()
        {
            //Add operations this class has to perform
            Move(15f);
            PlaySound("GroundDive");
            SpawnParticles();
        }
    }
    public class GameController : MonoBehaviour
    {
        List<Superpower> superPowers = new List<Superpower>();
        //스킬들을 저장하는 리스트

        void Start()
        {
            superPowers.Add(new SkyLaunch());
            superPowers.Add(new GroundDive());
        }

        void Update()
        {
            if (Input.GetKey(KeyCode.Space))
            {
                for (int i = 0; i < superPowers.Count; i++) { superPowers[i].Activate(); }
            }
        }
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂컴포넌트 객체를 통해서 제공📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace SubclassSandbox
{
    public class SoundPlayer {
        protected void playSound(SoundId sound, double volume) { /*...*/ }
        protected void stopSound(SoundId sound) { /*...*/ }
        protected void setVolume(SoundId sound) { /*...*/ }
    };

    //Superclass
    public abstract class Superpower
    {        
        private SoundPlayer soundPlayer;

        //Active 함수는 서브클래스에서 상속받아 사용될 Sandbox 매소드다.
        public abstract void Activate();

        //이 클래스들은 이제 서브클래스에서 지지고 볶을수 있는 매소드다
            //정말 상위클래스는 하위클래스에게 모든걸 주는구나 = 하위클래스는 오직 상위 클래스간 커플링이 있구나.
        protected void Move(float speed) { Debug.Log("Moving with speed " + speed); }

        protected SoundPlayer GetSoundPlayer() {return this.soundPlayer;}
        protected void SpawnParticles() {/*...*/}
    }


    //Subclasses
    public class SkyLaunch : Superpower
    {
        //본격적으로 상속받은 샌드박스 메소드를 구체화 한다.
        public override void Activate()
        {
            //Add operations this class has to perform
            Move(10f);
            PlaySound("SkyLaunch");
            SpawnParticles();
        }
    }

    //Subclasses
    public class GroundDive : Superpower
    {
        //Has to have its own version of Activate()
        public override void Activate()
        {
            //Add operations this class has to perform
            Move(15f);
            PlaySound("GroundDive");
            SpawnParticles();
        }
    }
    public class GameController : MonoBehaviour
    {
        List<Superpower> superPowers = new List<Superpower>();
        //스킬들을 저장하는 리스트

        void Start()
        {
            superPowers.Add(new SkyLaunch());
            superPowers.Add(new GroundDive());
        }

        void Update()
        {
            //Activate each superpower each update
            for (int i = 0; i < superPowers.Count; i++) { superPowers[i].Activate(); }
        }
    }
}
```
</details>

<details>
   <summary style="cursor:pointer; text:bold"><b>📂서브클래스 샌드박스로 몬스터 구현📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->

<p align="center">
  <img src=https://imgur.com/KPfIgsw.png width=800px>
</p>


<p align="center">
  <img src=https://imgur.com/x0OKkoe.png width=800px>
</p>

```cs
public class Monster {
    public Monster(){}

    protected int hp, damage, movespeed;
    protected Vector3 = new Vector3(0,0,0);
    protected abstract void attack();
    protected void walk(string animantion, int speed) {
        updateAnimation(animantion);
        setSpeed(speed);
    };

}

public class Ogre : Monster{
    public Ogre() {
        this.damage = 10;
        this.hp = 100;
        this.movespeed = 5;
    }
    public override void attack() {
        /*느리지만 존나 아픈 몽둥이 떄리맥이고~ */
    }
}
public class Skeleton : Monster{
    public Skeleton() {
        this.damage = 5;
        this.hp = 10;
        this.movespeed = 10;
    }
    public override void attack() {
        /* 와 샌즈! 블라스트!*/
    }
}
public class Ghoul : Monster{
    public Ghoul() {
        this.damage = 5;
        this.hp = 30;
        this.movespeed = 1;
    }
    public override void attack() {
        /*으어*/
    }
}
```
멈추는 방법을 도입하여 각 몬스터에게 좀 더 유연하게 움직일 수 있도록 합시다. 

<p align="center">
  <img src=https://imgur.com/10h18QX.png width=800px>
</p>

```cs
public class Movement {
    void walk(string animation, int speed) {
        updateAnimation(animation);
        setSpeed(speed);
    }
    void run(string animation) {
        updateAnimation(animation);
        setSpeed(speed);
    }
    void stop(string animation) {
        updateAnimation(animation);
        setSpeed(speed);
    }
}

public class Monster {
    public Monster(){}

    protected int hp, damage, movespeed;
    protected Vector3 = new Vector3(0,0,0);
    protected Movement movement;
    abstract void attack();
    protected void movement(string animation, int speed)
    {
        if(speed == movespeed*2) { movement.run(animation,speed); }
        else if(speed == movespeed) { movement.walk(animation,speed); }
        else { movement.stop(animation, speed); }
    }
    protected Movement GetMovement(return this.movement;)
}

public class Ogre : Monster{
    public Ogre() { this.damage = 10; this.hp = 100; this.movespeed = 5; }
    public override void attack() {
        /*느리지만 존나 아픈 몽둥이 떄리맥이고~ */
    }
}
public class Skeleton : Monster{
    public Skeleton() { this.damage = 5; this.hp = 10; this.movespeed = 10; }
    public override void attack() {
        /* 와 샌즈! 블라스트!*/
    }
}
public class Ghoul : Monster{
    public Ghoul() { this.damage = 5; this.hp = 30; this.movespeed = 1;}
    public override void attack() {
        /*으어*/
    }
}
```

<p align="center">
  <img src=https://imgur.com/yXsOrZi.png width=800px>
</p>

```cs
public class Movement
{
    public void walk(string animation, int speed) { }
    public void run(string animation) { }
    public void stop(string animation) { }
}

public abstract class Monster
{
    public Monster(Movement movement) { 
        this.movement = movement;
    }

    public abstract void Attack();

    protected int hp, damage, movespeed;
    protected int x, y, z;
    protected Movement movement;
    protected void Move(string animation, int speed)
    {
        if (speed == movespeed * 2) { movement.run(animation); }
        else if (speed == movespeed) { movement.walk(animation, speed); }
        else { movement.stop(animation); }
    }
    protected Movement GetMovement() { return this.movement; }
}

public abstract class ThingsThatFart : Monster
{
    public ThingsThatFart(Movement movement) : base(movement) { }
    public abstract void Fart();
}

public class Ogre : ThingsThatFart
{
    public Ogre(Movement movement) : base(movement) { this.damage = 10; this.hp = 100; this.movespeed = 5; }
    public override void Attack()
    {
        /*느리지만 존나 아픈 몽둥이 떄리맥이고~ */
    }
    public override void Fart()
    {
        /*푸드&*^&ㄲ*(@!*(!&*!#)(*%&(!)#%&#&득!*/
    }
}

public class Orc : ThingsThatFart
{
    public Orc(Movement movement) : base(movement) { this.damage = 10; this.hp = 100; this.movespeed = 5; }
    public override void Attack()
    {
        /*느리지만 존나 아픈 몽둥이 떄리맥이고~ */
    }
    public override void Fart()
    {
        /*푸득*/
    }
}
public class Skeleton : Monster
{
    public Skeleton(Movement movement) : base(movement) { this.damage = 5; this.hp = 10; this.movespeed = 10; }
    public override void Attack()
    {
        /* 와 샌즈! 블라스트!*/
    }
}
public class Ghoul : Monster
{
    public Ghoul(Movement movement) : base(movement) { this.damage = 5; this.hp = 30; this.movespeed = 1; }
    public override void Attack()
    {
        /*으어*/
    }
}
```

</details>


1. [SubclassSandbox Unity](./src/Design/UnityAdaptation/11.%20Subclass%20Sandbox/README.md)

#### 2). Event queue : Decoupling Patterns
* Decouple when a message or event is sent from when it is processed.

#### 3). ✨ Object Pool ✨ : Optimization Patterns
* Improve performance and memory use by reusing objects from a fixed pool instead of allocating and freeing them individually.
* 이 패턴은 매우 인기가 있어 Unity는 ObjectPool으로 사용가능하다.



### 📄 6. 참고

<details>
   <summary style="cursor:pointer; text:bold"><b>📂📂</b></summary>

   <!-- summary 아래 한칸 공백 두어야함 -->
```cs
```
</details>


1. [코드없는 프로그래밍 SOLID](https://www.youtube.com/watch?v=jlQkWM7Tu7o&list=PLDV-cCQnUlIZcWXE4PrxJx6U3qKfRTJcK&index=1)
2. https://github.com/accesto/solid-php
3. https://accesto.com/blog/solid-php-solid-principles-in-php/
4. https://korstrix.github.io/index/Index/
5. https://github.com/Habrador/Unity-Programming-Patterns
6. https://gameprogrammingpatterns.com/contents.html
7. https://csharpindepth.com/articles/singleton
8. [싱글톤 개요](https://cjw-awdsd.tistory.com/42)
9. [싱글톤 c#](http://egloos.zum.com/sweeper/v/3157853)
10. [싱글톤 c#](https://nochoco-lee.tistory.com/676)
11. [Master Singleton: in unity the right way](https://gamedevbeginner.com/singletons-in-unity-the-right-way/)
12. [Master Singleton Video](https://www.youtube.com/watch?v=tcatvGLvCDc)
13. [컴포 패턴](https://www.youtube.com/watch?v=XXvrHAsfTso)
14. [컴포 패턴](https://8iggy.tistory.com/238)
15. [컴포 패턴](https://en.wikipedia.org/wiki/Composite_pattern)
16. [샌드박스](https://teamalphaaleph.wordpress.com/2016/03/03/subclass-sandbox-an-introduction/)
17. [서브클래스 샌드박스](https://lipcoder.tistory.com/140)
18. [서브클래스 샌드박스](https://teamalphaaleph.wordpress.com/2016/03/03/subclass-sandbox-an-introduction/)
19. [서브클래스 샌드박스](https://www.habrador.com/tutorials/programming-patterns/11-subclass-sandbox-pattern/)
20. [서브클래스 샌드박스](https://teamalphaaleph.wordpress.com/2016/03/03/subclass-sandbox-an-introduction/)
21. [커맨드 패턴](https://www.youtube.com/watch?v=bUULgkwaicQ)
22. [커맨드 패턴](https://www.youtube.com/watch?v=7Pj5kAhVBlg)
23. [상태 패턴](https://www.youtube.com/watch?v=XNwAfxaqWEc)
24. [상태 패턴](https://github.com/almartson/AI_StateMachine_DronesDemo)
25. [상태 패턴](https://github.com/JoanStinson/UnityDesignPatternsReference/tree/main/Retro%20RPG%20Patterns/Assets/Scripts/Patterns/State)
26. [상태 패턴](https://www.youtube.com/watch?v=MGEx35FjBuo)
27. [FSM](https://boycoding.tistory.com/262)
28. [FSM](https://www.youtube.com/watch?v=O_NJaHpbjaI)
29. [FSM](https://www.youtube.com/watch?v=MowE3moQ_Cw)
30. [디자인패턴 아티클](https://refactoring.guru/design-patterns/structural-patterns)